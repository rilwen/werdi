#ifndef _HAMILTONIAN_H
#define _HAMILTONIAN_H

#include <stdio.h>
#include "doublecomplex.h"

typedef struct my_ham_struct {
	int dim;
	int p_bands_start;
	int p_bands_cnt;
	double Ex;
	double Ey;
	double Ez;
	double D;
	double magdir[3]; /* Magnetization direction */
	double L; /* Length unit in nm */
	double MnX; /* Mn concentration, fractional */
	double cosine_product; /* Product of cosines between basis vectors of real and reciprocal lattice */
	double cosine_product_12; // Like cosine_product but only for b1 and b2
	double volume_factor; /* Factor by which we multiply concentration when recalculating it into number of states; if a_1,..., a_3 are the basis vectors
	of real lattice, then V = volume_factor * |a_1| * |a_2| * |a_3|, where V is the volume spun by vectors a_1, ..., a_3 */
	double volume_factor_12; // Like volume_factor, but only for a1 and a2
	double kx_vect[3]; /* kx vector of length 1/L in the Brillouin zone basis */
	double ky_vect[3]; /* ky vector of length 1/L in the Brillouin zone basis */
	double kz_vect[3]; /* kz vector of length 1/L in the Brillouin zone basis */
	
	double bvect_lengths[3]; /* lengths of the k-space basis vectors, in program units */
	int periodic_bc_dim; // Dimension of the space in which we have periodic boundary conditions: 3 for bulk, 2 for planes

	double width; // Width of the dimensions in which we don't have the periodic boundary conditions
	
	int inverted_fermi; // Tells us whether the Fermi energy is the maximum (1) or minimum (0) energy of occupied states.
	doublecomplex* work_matrix; /* Matrix of the dimension equal to the hamiltonian dimension */
	double* work_vector; /* Double vector with length equal to the hamiltonian dimension */
	void (*gen_ham) (const struct my_ham_struct* this, double c1, double c2, double c3, doublecomplex* matrix);

	/* Calculate the derivative of the Hamiltonian in wave vector (c1,c2,c3) along the direction (d1,d2,d3), WITHOUT normalizing the derivative by the length of vector (d1,d2,d3). We don't normalize because in some geometries c's and d's are coordinates in a non-orthogonal system and we don't know how to compute the length of (d1,d2,d3).
	 */
	void (*gen_ham_derivative) (const struct my_ham_struct* this, double c1, double c2, double c3, double d1, double d2, double d3, doublecomplex* matrix);
	
	const doublecomplex* S_z;
	const doublecomplex* S_x;
	const doublecomplex* S_y;
	const doublecomplex* S_minus;
	const doublecomplex* S_plus;
	double (*find_cstep) (struct my_ham_struct* this, double pmax, int npts); // Find desired step in c (c's multiply basis vectors of the reciprocal lattice) for estimation of EF

	/* Integrand over Brillouin zone, which converts Cuba variables x (from [0,1]) into correct c values and computes the integrated function fun */
	double (*bril_zone_integrand) (struct my_ham_struct* this, double (*int_fun)(double c1, double c2, double c3), const double* x);
	
	/*
	Factor by which we multiply integrals over d^nc to convert them into limits of sums divided by V for V --> infty
	*/
	double (*sum2integral_prefactor)(struct my_ham_struct* this);

	// "Destructor" which should be called to free the ham_struct */
	void (*destroy)(struct my_ham_struct* this);

	// xx strain coefficient
	double exx;
} ham_struct;

/* Calculate the discretized derivative of the hamiltonian generated by supplied structure. Requires the initialization of the work matrix first. */
void discretized_5pt_derivative(ham_struct * this, double kx, double ky, double kz, double cx, double cy, double cz, doublecomplex matrix[][]);

/* Set up a vanilla ham_struct with dimension dim, and Mn fractional concentration MnX, ready for action! */
void setup_ham_struct(ham_struct* hs, double MnX, int dim, int periodic_bc_dim);


/* Destroy a vanilla ham_struct */
void destroy_ham_struct(ham_struct* this);

/* Return the structure with Fermi energies */
double* find_EF(ham_struct* this, double pmin, double dp, double pmax, double Dmin, double dD, double Dmax, int nkmax);

/* Return a single Fermi energy */
double find_single_EF(ham_struct* this, double p, double D, int nkmax);

/* Return a single Fermi energy using a preallocated buffer */
double find_single_EF_preallocated(ham_struct* this, double p, double D, int nkmax, double* energies);

/* Calculate states' and Fermi energies for ranges of D and p using a preallocated buffer */
void find_EF_preallocated(ham_struct* this, double pmin, double dp, int plen, double Dmin, double dD, int Dlen, int nkmax, double* energies, double* EFtab);

int calculate_en_cnt(ham_struct* this, int ncmax);

/* Return the number of values in a for loop (for val = min; val <= max. val += step) */
int count_values(double min, double max, double step);

/* Scan bands, taking direction in program units (this->L) and multiplying it by numbers from -1 to 1. Save data to file output. */
void scan_bands(ham_struct* this, double cx, double cy, double cz, FILE* output);

/* Scan bands' <sz>, taking direction in program units (this->L) and multiplying it by numbers from -1 to 1. Save data to file output. */
void scan_bands_sz(ham_struct* this, double cx, double cy, double cz, FILE* output);

/* Delta at T=0 for fractional Mn concentration x */
double Delta0(ham_struct* this);

/* Converte Cartesian wave vector corrdinates into the reciprocal lattice coordinate system. */
void translate_into_inner_coords(const ham_struct* this, double kx, double ky, double kz, double* c1, double* c2, double* c3);

/*
 * pmax - concentration which we expect to be the upper bound of the concentration we will obtain from the calculation. Some implementations
 * of the hamiltonian may not depend on this parameter.
 */
double find_concentration(ham_struct* this, double EF, int nkmax, double pmax);

#endif
